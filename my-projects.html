<!doctype html><html lang="pl"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Projekty</title><link href="index.d3ffd2e3.css" rel="stylesheet"></head><body><header class="header"><nav class="menu menu--js"><a class="menu__page menu__page--homepage" href="./index.html">Strona główna</a> <a class="menu__page" href="./html.html">Skille</a> <a class="menu__page" href="./css.html">CSS</a> <a class="menu__page" href="./my-projects.html">JavaScript</a> <a class="menu__page" href="./skills-and-tools.html">Skille</a></nav><div class="hamburger hamburger--js"><div class="hamburger__bar"></div><div class="hamburger__bar"></div><div class="hamburger__bar"></div></div></header><main class="main"><img src="img/gorkiwielkie.79085181.jpg" alt="Panorama z ul.Widokowej"><div class="grid"><article class="project"><h2 class="project__name">Kamień, papier, nożyce</h2><a href="./game.html">Link do projektu</a><p class="project__description">Dzisiaj napisałam grę w kamień, papier i nożyce, do zabawy z komputerem. Na stronie głównej mojej gry zamieściłam udostępnione przez Samuraja grafiki ilustrujące wybór gracza. Po zaznaczeniu jednej z nich i kliknięciu przycisku "Start" następuje wywołanie metody <span class="italics">computerChoice()</span>, losującej element z 3-el. tablicy. Wybory gracza i komputera są w każdej grze przekazywane do obiektu game. Metoda <span class="italics">getResult()</span> wyłania zwycięzcę gry na podstawie odpowiednich warunków oraz aktualizuje licznik zwycięstw/porażek i remisów. Metoda <span class="italics">viewResults() </span>odpowiada za wyświetlenie aktualnej statystyki w odpowiednich polach w widoku.</p></article><article class="project"><h2 class="project__name">Projekt bannera ze zmieniającymi się grafikami</h2><a href="./banner.html">Link do projektu</a><p class="project__desc">W projekcie należało zapewnić dwie podstawowe funkcjonalności mojego bannera:</p><ul class="list"><li>automatyczne przełączanie tła wraz z podświetlaniem odpowiadającej mu kropki</li><li>możliwość manualnej nawigacji między kropkami i tłami za pomocą strzałek (lewo-prawo).</li></ul>Projek wymusił na mnie kilka podejść i sporo główkowania. Największym problemem było zapewnienie bezkolizyjnego współdziałania tych dwóch funkcjonalności i płynnego przejścia między nimi. Kluczowe okazało się manewrowanie interwałem czasowym wywoływania funkcji automatycznej zmiany tła. Napotkałam też problemy przy ograniczaniu obszaru zmiany grafik do konkretnej liczby elementów (tutaj 3).<p></p></article><article class="project"><h2 class="project__name">Stoper</h2><p class="project__description">W projekcie stopera tworzenie obiektu Date do odliczania czasu nie jest konieczne. Moja metoda <span class="italics">runStopwatch()</span> co 10ms inkrementuje i wyświetla licznik "tików zegara". Po wystartowaniu stopera możliwe jest zapauzowanie go tym samym przyciskiem oraz ponowne uruchomienie. Każdy kolejny rozpoczęty etap odliczania jest sumowany z poprzednimi. Kliknięcie przycisku "Reset" powoduje wyzerowanie licznika.</p><div class="timer"><button class="timer__button-start-stop">Start</button> <button class="timer__button-reset">Reset</button><p>Czas od startu:</p><div class="timer__display">...</div></div></article></div></main><script src="index.d3ffd2e3.js"></script><script src="timer.d3ffd2e3.js"></script></body></html>